{"componentChunkName":"component---src-components-templates-blog-post-index-tsx","path":"/2018-10-22/kotlin-master-standard/","webpackCompilationHash":"05f8a5976b0a7a1dd32f","result":{"data":{"markdownRemark":{"html":"<p style=\"text-align:center;\"><img src=\"https://user-images.githubusercontent.com/1689721/66471415-3a0f0d80-eac6-11e9-8e7b-5c6ebbc39f09.png\" alt=\"Kotlin\" style=\"height:150px;\"></p>\n<p>※ 본 게시글은 해외 포스팅을 번역한 글입니다.<br>\n원본 : <a href=\"https://medium.com/@elye.project/mastering-kotlin-standard-functions-run-with-let-also-and-apply-9cd334b0ef84\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Elye's Medium</a></p>\n<p>코틀린에는 어떻게 사용해야할지 확실하지 않을 정도로 유사한 표준함수가 있습니다.\n이들의 차이점과 어떤걸 선택해야하는지 명확하게 구별하는 쉬운방법을 소개하겠습니다.</p>\n<h1 id=\"스코프-함수\"><a href=\"#%EC%8A%A4%EC%BD%94%ED%94%84-%ED%95%A8%EC%88%98\" aria-label=\"스코프 함수 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스코프 함수</h1>\n<p>저는 <em>run, with, T.run, T.let, T.also</em> 그리고 <em>T.apply</em>에 초점을 맞췄습니다. 저는 호출 함수의 내부 스코프를 제공하는 것처럼 주요기능을 볼때 <strong>스코프 함수</strong>라 부릅니다.</p>\n<p>스코프 함수인 run함수를 쉬운방법으로 설명해드리겠습니다.</p>\n<p>{% include services/gist.html src=\"0df9ada5d40f58bbeb27f7c9143a3c99\" %}</p>\n<p><code class=\"language-text\">test</code>함수의 내부를 보면, <code class=\"language-text\">mood</code>를 출력전에 <code class=\"language-text\">I am happy</code>라고 재정의한 격리된 스코프가 있고, 이는 완전히 격리된 <code class=\"language-text\">run</code> 스코프입니다.</p>\n<p>이 스코프 함수 자체로는 매우 유용해 보이진 않습니다. 하지만 스코프보다 좋은 것이있습니다. 스코프의 마지막 객체를 반환하는 것입니다.</p>\n<p>아래의 적절한 예제로, 두개의 뷰에 두번 사용하지 않고 <code class=\"language-text\">show()</code>를 사용할 수 있습니다.</p>\n<p>{% include services/gist.html src=\"7be24605114325be6e84ad092f58b15e\" %}</p>\n<h1 id=\"스코프-함수의-3가지-속성\"><a href=\"#%EC%8A%A4%EC%BD%94%ED%94%84-%ED%95%A8%EC%88%98%EC%9D%98-3%EA%B0%80%EC%A7%80-%EC%86%8D%EC%84%B1\" aria-label=\"스코프 함수의 3가지 속성 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스코프 함수의 3가지 속성</h1>\n<p>스코프 함수들을 좀더 흥미롭게 만들려면, 3가지 속성을 분류하세요.\n저는 이런 속성들을 각각 구분하기 위해 사용할 것입니다.</p>\n<h2 id=\"1-일반-vs-확장-함수\"><a href=\"#1-%EC%9D%BC%EB%B0%98-vs-%ED%99%95%EC%9E%A5-%ED%95%A8%EC%88%98\" aria-label=\"1 일반 vs 확장 함수 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 일반 vs 확장 함수</h2>\n<p><code class=\"language-text\">with</code>와 <code class=\"language-text\">T.run</code>를 보면, 두 함수 모두 실제로 꽤 비슷합니다. 아래의 예제도 같습니다.</p>\n<p>{% include services/gist.html src=\"9fee472457d333b07a7ecb51439be027\" %}</p>\n<p>그러나, 둘의 차이는 <code class=\"language-text\">with</code>는 일반 함수고, <code class=\"language-text\">T.run</code>은 확장 함수입니다.</p>\n<p>그럼 질문, 각각의 이점은 무엇일까요?</p>\n<p><code class=\"language-text\">webview.settings</code>가 null이 될 수 있다고 생각해보면, 아래와 같이 보일겁니다.</p>\n<p>{% include services/gist.html src=\"d8795e837ef2b8ea82dd322c09fca8fb\" %}</p>\n<p><strong>이경우, 확실히 <code class=\"language-text\">T.run</code> 확장 함수가 사용하기 전에 null 체크를 적용할 수 있어 더 낫습니다.</strong></p>\n<h2 id=\"2-매개변수-code-classlanguage-textthiscode-vs-code-classlanguage-textitcode\"><a href=\"#2-%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98-code-classlanguage-textthiscode-vs-code-classlanguage-textitcode\" aria-label=\"2 매개변수 code classlanguage textthiscode vs code classlanguage textitcode permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 매개변수 <code class=\"language-text\">this</code> vs <code class=\"language-text\">it</code></h2>\n<p><code class=\"language-text\">T.run</code>과 <code class=\"language-text\">T.let</code>을 본다면, 두 함수 모두 매개 변수를 받는 것을 제외하고 닮았습니다.\n아래의 예제는 두 함수 모두 같은 로직입니다.</p>\n<p>{% include services/gist.html src=\"1454c5e68527b050917d4db8aa3cee71\" %}</p>\n<p><code class=\"language-text\">T.run</code>함수의 기호를 확인해보면, <code class=\"language-text\">T.run</code>은 <code class=\"language-text\">block: T.()</code>으로 보이는 확장함수로 만들어진 것을 알 수 있습니다. 그런 까닭에 스코프 내의 모든 곳에서 <code class=\"language-text\">T</code>는 <code class=\"language-text\">this</code>로 부를 수 있습니다. 프로그래밍에서, <code class=\"language-text\">this</code>는 대부분에서 생략될 수 있습니다. 그러므로 위의 예제에서, <code class=\"language-text\">println</code>에서 <code class=\"language-text\">${this.length}</code>대신, <code class=\"language-text\">length</code>로 사용할 수 있습니다. 저는 이를 <strong><em>this를 매개변수</em></strong>로 보낸다고 부릅니다.</p>\n<p>그러나 <code class=\"language-text\">T.let</code>함수의 기호에서, <code class=\"language-text\">T.let</code>은 자기자신을 <code class=\"language-text\">block: (T)</code>인 함수로 보낸다는걸 알 수 있습니다. 그런 까닭에 이는 람다 매개변수로 보내는 것 같습니다. 스코프 내에서는 <code class=\"language-text\">it</code>으로 불릴 수 있습니다. 따라서 저는 <strong><em>it을 매개변수</em></strong>로 보낸다 부릅니다.</p>\n<p>위에서는, <code class=\"language-text\">T.run</code>이 <code class=\"language-text\">T.let</code>보다 함축적으로 더 유용한 것으로 보입니다만, <code class=\"language-text\">T.let</code> 함수에는 아래와 같이 눈에 띄지않는 장점들이 있습니다.</p>\n<ul>\n<li><code class=\"language-text\">T.let</code>은 넘겨진 함수/멤버 변수인지, 외부 클래스의 함수/멤버 변수인지 명확하게 구분됩니다.</li>\n<li><code class=\"language-text\">this</code>가 생략되지 않는 상황에서, 예를들어 함수의 파라미터로 넘겨졌을 때, <code class=\"language-text\">it</code>은 <code class=\"language-text\">this</code>보다 짧게 쓸 수 있고, 보다 깔끔합니다.</li>\n<li><code class=\"language-text\">T.let</code>은 변수를 보다 나은 이름으로 바꿀 수 있습니다. 즉, <code class=\"language-text\">it</code>을 다른 이름으로 변환할 수 있습니다.</li>\n</ul>\n<p>{% include services/gist.html src=\"17e24f833ee329c500e75803f785a7a7\" %}</p>\n<h2 id=\"3-code-classlanguage-textthiscode-vs-다른-타입-반환\"><a href=\"#3-code-classlanguage-textthiscode-vs-%EB%8B%A4%EB%A5%B8-%ED%83%80%EC%9E%85-%EB%B0%98%ED%99%98\" aria-label=\"3 code classlanguage textthiscode vs 다른 타입 반환 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. <code class=\"language-text\">this</code> vs 다른 타입 반환</h2>\n<p>이제, <code class=\"language-text\">T.let</code>과 <code class=\"language-text\">T.also</code>를 살펴보면, 함수 내부의 스코프를 본다면, 둘다 똑같습니다.</p>\n<p>{% include services/gist.html src=\"f7c8c2a738f3e81e7c4a7ef971d11a2b\" %}</p>\n<p>그러나 그것들의 반환값이 파악하기 힘들게 다릅니다. <code class=\"language-text\">T.let</code>은 다른 타입의 값을 반환하지만, <code class=\"language-text\">T.also</code>는 <code class=\"language-text\">T</code> 자기 자신 즉, <code class=\"language-text\">this</code>를 반환합니다.</p>\n<p>둘다 체이닝 함수(chaining function)에서는 유용합니다. <code class=\"language-text\">T.let</code>은 조작을 진화시켜주고, <code class=\"language-text\">T.also</code>는 같은 변수 즉, <code class=\"language-text\">this</code>를 사용하게 해줍니다.</p>\n<p>아래의 간단한 실제 예제가 있습니다.</p>\n<p>{% include services/gist.html src=\"0f664fa3907e7492d6300996d608a182\" %}</p>\n<p>위의 <code class=\"language-text\">T.also</code>는 의미 없어 보이며, 쉽게 함수의 한개의 블럭으로 합칠 수 있습니다. 잘 생각해보면, 약간의 장점이 있습니다.</p>\n<ol>\n<li>같은 객체에서 작업을 깔끔하게 분리할 수 있습니다. 즉, 함수의 영역을 작게 만들수 있습니다.</li>\n<li>사용전에 체인 빌드 기능을 만드는 것에서 자기자신을 교묘히 다루는 것을 매우 강력해질 수 있습니다.</li>\n</ol>\n<p>체인을 합칠때 즉, 자기자신을 진화하고, 유지할때 아래와 같이 매우 강력해질 겁니다. </p>\n<p>{% include services/gist.html src=\"409992bceec59eb74a3a6a60d1f13ecc\" %}</p>\n<h1 id=\"모든-속성-보기\"><a href=\"#%EB%AA%A8%EB%93%A0-%EC%86%8D%EC%84%B1-%EB%B3%B4%EA%B8%B0\" aria-label=\"모든 속성 보기 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>모든 속성 보기</h1>\n<p>3개의 속성을 보면, 함수의 행동을 거의 알 수 있습니다. <code class=\"language-text\">T.apply</code> 위에서 말한것과 다르게, 함수를 설명해 봅시다. 아래에 <code class=\"language-text\">T.apply</code>의 3가지 속성이 있습니다.</p>\n<ol>\n<li>확장 함수 입니다.</li>\n<li><code class=\"language-text\">this</code>를 매개변수로 보냅니다.</li>\n<li><code class=\"language-text\">this</code>(즉, 자기자신)을 반환합니다.</li>\n</ol>\n<p>여기서 부터 사용해보면, 한가지로 아래와같이 상상할 수 있습니다.</p>\n<p>{% include services/gist.html src=\"e9c7ca9f452e1a4cf1c1044c7fc55950\" %}</p>\n<p>또는 체인되지 않은 객체를 체인할 수 있게 만들 수 있습니다.</p>\n<p>{% include services/gist.html src=\"d7ad797cccfd0b969cbfd613ab877f2a\" %}</p>\n<h1 id=\"함수-선택\"><a href=\"#%ED%95%A8%EC%88%98-%EC%84%A0%ED%83%9D\" aria-label=\"함수 선택 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>함수 선택</h1>\n<p>명백히 이제 3개의 속성으로, 함수들을 카테고리로 나눌 수 있습니다. 그리고 이것으로, 우리가 필요할때 어떤 함수를 사용해야 하는지 결정을 도와줄 수 있는 아래와 같은 결정 트리 형식을 만들 수 있습니다.</p>\n<p style=\"text-align:center;\"><img src=\"{{ site.url }}/assets/kotlin/function_choose_flowchart.png\" alt=\"Kotlin\" style=\"width:100%;\"></p>\n<hr>\n<p>오역, 의역 등 문제점이 있을 수 있습니다. 이러한 경우 댓글로 알려주시기 바랍니다.</p>\n<p>처음 번역해 올려보는거라 이미지가 번역이 안된점이 아쉽지만, 이는 후에 포스트를 업데이트 하겠습니다.</p>","frontmatter":{"title":"Kotlin 표준 함수 마스터하기","date":"2018.10.22","category":"Kotlin"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2018-10-22/kotlin-master-standard/","previous":{"fields":{"slug":"/2018-10-06/kotlin-readline/"},"frontmatter":{"title":"Kotlin 콘솔에서 입력받는 3가지 방법","template":"BlogPost"}},"next":{"fields":{"slug":"/2018-11-04/kotlin-master-standard/"},"frontmatter":{"title":"Kotlin 확장 함수 활용하기","template":"BlogPost"}}}}}